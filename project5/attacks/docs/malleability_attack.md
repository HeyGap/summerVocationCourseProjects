# 签名延展性 (Malleability) 攻击分析

## 攻击原理

签名延展性是指在不知道私钥的情况下，攻击者能够对一个有效的数字签名进行修改，产生另一个对同一消息同样有效的签名。这种攻击利用了椭圆曲线数字签名算法的数学性质。

## 数学推导

### ECDSA/SM2 签名延展性

对于椭圆曲线数字签名 (r, s)，存在以下数学性质：

#### 基本延展性

给定有效签名 (r, s)，以下签名对同一消息也是有效的：

1. **(r, -s mod n)**：由于椭圆曲线的点对称性
2. **(r, n - s)**：等价于上述情况，因为 -s ≡ n - s (mod n)

#### 数学证明

**原始签名验证方程**：
```
u₁ = s⁻¹ · e mod n
u₂ = s⁻¹ · r mod n  
(x, y) = u₁G + u₂P
验证：r ≡ x (mod n)
```

**延展签名 (r, n-s) 的验证**：
```
s' = n - s
u₁' = (s')⁻¹ · e = (n-s)⁻¹ · e = (-s)⁻¹ · e = -s⁻¹ · e mod n
u₂' = (s')⁻¹ · r = (-s)⁻¹ · r = -s⁻¹ · r mod n
(x', y') = u₁'G + u₂'P = -(s⁻¹ · e · G + s⁻¹ · r · P) = -(x, y)
```

由于椭圆曲线上的点 (x, y) 和 (x, -y) 具有相同的 x 坐标：
```
x' = x  
r' ≡ x' ≡ x ≡ r (mod n)
```

因此延展签名 (r, n-s) 也能通过验证。

### SM2 特定的延展性

SM2 签名算法的延展性稍有不同，因为其 r 值的计算方式不同：

**SM2 签名生成**：
```
r = (e + x₁) mod n，其中 (x₁, y₁) = kG
s = d⁻¹(k - rd) mod n
```

**SM2 签名验证**：
```
t = (r + s) mod n
(x₁', y₁') = sG + tP
验证：r ≡ (e + x₁') (mod n)
```

对于 SM2，延展性主要体现在：
- **(r, n-s)**：修改 s 值
- 由于验证过程的不同，延展性的效果也有所不同

### 高级延展性攻击

#### 相关签名攻击

如果攻击者能够获得相关消息的签名，可能产生更复杂的延展性攻击：

给定消息 m₁ 和 m₂ 的签名 (r₁, s₁) 和 (r₂, s₂)，攻击者可能构造：
- 消息 m₃ = m₁ ⊕ m₂ 的伪造签名
- 线性组合消息的伪造签名

#### Wagner 算法相关攻击

对于多重签名或聚合签名，攻击者可以使用 Wagner 算法进行更高级的延展性攻击：

1. 收集大量部分签名
2. 通过生日攻击找到碰撞
3. 构造满足特定关系的延展签名

## 攻击场景与影响

### 比特币交易延展性

在比特币等数字货币中，签名延展性可能导致：

1. **交易 ID 变化**：同一笔交易可能有多个有效的交易 ID
2. **双花攻击**：利用延展性创建看似不同的交易
3. **钱包混乱**：钱包软件可能无法正确追踪交易状态

### 智能合约安全

在智能合约系统中：

1. **重入攻击**：利用签名延展性绕过重复性检查
2. **授权绕过**：通过修改签名绕过访问控制
3. **状态不一致**：导致合约状态与预期不符

### 多重签名系统

在多重签名系统中：

1. **阈值绕过**：攻击者可能通过延展性减少所需签名数量
2. **身份混淆**：延展签名可能导致签名者身份识别错误
3. **审计困难**：延展性使得审计轨迹变得复杂

## 检测方法

### 静态分析

**签名格式检查**：
```python
def detect_malleability(r, s, curve_order):
    """检测签名延展性"""
    # 检查 s 值是否在低半区
    if s > curve_order // 2:
        return True, "高 s 值，可能存在延展性"
    return False, "正常签名"
```

**批量分析**：
```python
def batch_malleability_check(signatures):
    """批量检查签名延展性"""
    malleable_pairs = []
    for i, sig1 in enumerate(signatures):
        for j, sig2 in enumerate(signatures[i+1:], i+1):
            if sig1[0] == sig2[0]:  # 相同 r 值
                if (sig1[1] + sig2[1]) % curve_order == 0:
                    malleable_pairs.append((i, j))
    return malleable_pairs
```

### 动态监控

**实时签名监控**：
1. 监控相同 r 值的签名
2. 检测 s 和 n-s 的签名对
3. 分析签名时间和来源

**模式识别**：
1. 使用机器学习检测异常签名模式
2. 建立签名延展性特征库
3. 实时告警和阻断

## 防护措施

### RFC 6979 确定性签名

使用 RFC 6979 标准生成确定性签名：

```python
def deterministic_k(private_key, message_hash):
    """RFC 6979 确定性 k 生成"""
    # 基于私钥和消息哈希生成确定性 k
    # 确保相同输入总是产生相同的 k
    pass
```

### 规范化签名

强制使用低 s 值（s ≤ n/2）：

```python
def canonicalize_signature(r, s, curve_order):
    """规范化签名，使用低 s 值"""
    if s > curve_order // 2:
        s = curve_order - s
    return r, s
```

### 签名唯一性验证

```python
def verify_signature_uniqueness(signature, message, public_key):
    """验证签名唯一性"""
    r, s = signature
    
    # 检查是否为规范形式
    if s > curve_order // 2:
        return False, "非规范签名，存在延展性"
    
    # 验证签名有效性
    if not verify_signature(signature, message, public_key):
        return False, "无效签名"
    
    return True, "有效且唯一的签名"
```

### 协议层防护

**交易 ID 计算**：
- 使用规范化签名计算交易 ID
- 在签名之前计算交易哈希
- 使用见证隔离 (SegWit) 等技术

**合约层验证**：
- 智能合约中加入签名规范性检查
- 使用 nonce 防止重放攻击
- 实施严格的签名验证逻辑

## 攻击复杂度分析

### 时间复杂度
- **简单延展性**：O(1) - 立即可得
- **相关消息攻击**：O(2^(n/2)) - 生日攻击复杂度
- **Wagner 算法**：O(n·2^(n/4)) - 依赖于参数数量

### 空间复杂度
- **存储需求**：O(1) 到 O(2^(n/4))，取决于攻击类型
- **内存使用**：主要用于存储中间计算结果

### 成功概率
- **基础延展性**：100% - 数学确定性
- **高级攻击**：依赖于具体场景和防护措施
- **检测概率**：高，延展签名容易被检测

### 实际影响
- **金融损失**：可能导致双花或资产冻结
- **系统可用性**：影响交易确认和处理
- **用户体验**：造成交易状态混乱
